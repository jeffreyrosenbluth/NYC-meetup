<html><head><meta charset="utf-8"><title>Diagrams 1.3</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="css/reveal.css" rel="stylesheet"><link href="css/theme/white.css" id="theme" rel="stylesheet"><link href="lib/css/github.css" rel="stylesheet"></head><body><div class="reveal"><div class="slides"><section><section><h2>diagrams</h2><h3>Declarative domain-specific language for creating vector graphics</h3><ul><li><a href="http://projects.haskell.org/diagrams/">http://projects.haskell.org/diagrams/</a></li><li> diagrams-core</li><li>diagrams-lib</li><li>diagrams-svg, diagrams-rasterific, ...</li><li>cabal update &amp;&amp; cabal install diagrams</li></ul><aside class="notes"><ul><li>How many here have used diagrams?</li><li>website has tutorials, manual, gallery, blog, reference</li></ul></aside></section><section><img src="./meetup/website.png"></section><section><h2>5 Active Developers</h2><h3>67 Contributors</h3><ul><li>Chris Chalmers</li><li>Daniel Bergey</li><li>Jeffrey Rosenbluth</li><li>Ryan Yates</li><li>Brent Yorgey</li></ul><aside class="notes"><ul><li>The diagrams team</li><li>see blog post contributors list</li></ul></aside></section></section><section><section><h2>Diagrams 1.3 released</h2><h3>Projections</h3><img width="500" src="./meetup/projections.svg"><aside class="notes"><ul><li>plus lots more</li></ul></aside></section><section><h2>Diagrams 1.3</h2><h3>Path Intersections</h3><img width="600" src="./meetup/intersections.png"></section><section><h2>Diagrams 1.3</h2><h3>Grouping for Opacity</h3><img width="600" src="./meetup/group-opacity.png"></section><section><h2>Diagrams 1.3</h2><h3>New Backends</h3><ul><li>diagrams-pgf</li><li>diagrams-canvas</li><li>diagrams-hmlt5</li></ul></section></section><section><h2>A Diagram</h2><img width="300" src="./meetup/firstDiagram.svg"><pre><code data-trim="contenteditable" class="haskell">{-# LANGUAGE NoMonomorphismRestriction #-}

import Diagrams.Prelude
import Diagrams.Backend.SVG.CmdLine

diagram :: Diagram B
diagram = circle 1 # lw ultraThick # lc purple # fc orange

main = mainWith $ frame 0.1 diagram
</code></pre><aside class="notes"><ul><li>NoMonoMorphismRestriction important to avoid crazy error messages</li><li>import a backend, plugable</li><li>Diagram B - a type alias for 2d diagrams</li><li>mainWith vs defaultMain</li><li>not going to show mainWith from here in</li></ul></aside></section><section><section><h2>Composing Diagrams</h2><h3>atop</h3><img width="250" src="./meetup/atop.svg"><pre><code data-trim="contenteditable" class="haskell">c1 = circle 0.5 # fc steelblue
c2 = circle 1   # fc orange

diagram :: Diagram B
diagram = c1 `atop` c2

diagram&#39; :: Diagram B
diagram&#39; = c1 &lt;&gt; c2
</code></pre><aside class="notes"><ul><li>default line color is black</li><li>defalut fill color is transparent</li><li>diagrams are monoids</li><li>atop == &lt;&gt;</li></ul></aside></section><section><h2>Composing Diagrams</h2><h3>Side by Side</h3><img width="300" src="./meetup/atop2.svg"><pre><code data-trim="contenteditable" class="haskell">c1 = circle 0.5 # fc steelblue
c2 = circle 1   # fc orange

diagram :: Diagram B
diagram = c1 ||| c2

diagram&#39; :: Diagram B
diagram&#39; = c1
           ===
           c2
</code></pre></section><section><h2>Composing Diagrams</h2><h3>Every diagram has a local origin</h3><img width="400" src="./meetup/atop3.svg"><aside class="notes"><ul><li>You can think of it as the point (0,0) on global grid</li></ul></aside></section><section><h2>Composing Diagrams</h2><h3>Local Origin</h3><img width="300" src="./meetup/atop4.svg"><pre><code data-trim="contenteditable" class="haskell">c1 = circle 0.5 # fc steelblue
c2 = circle 1   # fc orange

diagram :: Diagram B
diagram = (c1 &lt;&gt; c2) # showOrigin
</code></pre><aside class="notes"><ul><li>Places all local origings at (0,0)</li></ul></aside></section><section><h2>Side by Side</h2><h3>||| is moveOriginTo + atop</h3><img width="400" src="./meetup/atop5.svg"><aside class="notes"><ul><li>moves origin of orange circle left</li><li>leaves origin of blue circle alone</li><li>combine with &lt;&gt;</li></ul></aside></section><section><h2>Composing Diagrams</h2><h3>with beside</h3><img width="300" src="./meetup/atop6.svg"><pre><code data-trim="contenteditable" class="haskell">c1 = circle 0.5 # fc steelblue
c2 = circle 1   # fc orange

diagram :: Diagram B
diagram = beside (1 ^&amp; 1) c1 c2 # showOrigin
</code></pre><aside class="notes"><ul><li>||| == beside (1,0)</li><li>explain ^&amp;</li></ul></aside></section><section><h2>Moral</h2><h4>All defined in terms of atop and moveOriginTo</h4><ul><li>besde, |||, ===</li><li>cat, hcat, vcat, hsep, vsep</li><li>juxtapose</li><li>position</li><li>appends</li></ul></section></section><section><section><h4>How do we know where to place diagrams when composing so that they don&#39;t overlap?</h4><ul><li><del>Bounding Boxes</del></li><li>Envelopes</li></ul></section><section><h2>Bounding Boxes</h2><h3>beside (1, 1)</h3><img width="400" src="./meetup/boundingbox.svg"><aside class="notes"><ul><li>notice beside doesn&#39;t really work like this</li><li>not compositional</li><li>not general</li><li>what to do with bounding box under rotation</li><li>bounding paths are complicated</li></ul></aside></section><section><h2>Envelopes</h2><img width="500" src="./meetup/envelope.svg"><aside class="notes"><ul><li>how far to supporting hyperplane</li></ul></aside></section><section><h2>Envelopes</h2><h3>beside (1, 1)</h3><img width="400" src="./meetup/envelope2.svg"><aside class="notes"><ul><li>Now we see the connection between envelopes and atop</li></ul></aside></section><section><h2>Envelopes</h2><h3>beside (1, 1)</h3><img width="400" src="./meetup/envelope4b.svg"><aside class="notes"><ul><li>What do you think happens if `beside (1.5 ^&amp; 1)`</li><li>think of line with sope 2/3 from left origin</li></ul></aside></section><section><h2>Envelopes</h2><h3>beside (1.5, 1)</h3><img width="400" src="./meetup/envelope4a.svg"></section><section><h2>Envelopes</h2><h3>beside (1.5, 1)</h3><img width="400" src="./meetup/envelope4.svg"><aside class="notes"><ul><li>We can move these squares closer along line connection origins</li><li>What is going on?</li></ul></aside></section><section><h2>Envelopes</h2><h3>Depend on the local origin</h3><ul><li>not always intuitive</li><li>extensional not intensional</li><li>not the same as the convex hull</li></ul><img width="500" src="./meetup/envelope3.svg"><p><a href="https://github.com/diagrams/diagrams-doc/blob/master/envelope/envelope.pdf/">https://github.com/diagrams/diagrams-doc/blob/master/envelope/envelope.pdf</a></p></section><section><h2>Align</h2><h3>Moves the local origin to the envelope</h3><img width="300" src="./meetup/align.svg"><pre><code data-trim="contenteditable" class="haskell">h = hexagon 1 # fc lightgreen

sOrigin = showOrigin&#39; (with &amp; oScale .~ 0.04)

diagram :: Diagram B
diagram = h # alignR  # sOrigin
       &lt;&gt; h # alignBL # sOrigin
       &lt;&gt; h # alignTL # sOrigin
</code></pre><aside class="notes"><ul><li>primed versions like showOrigin&#39; take an default record</li><li>see section 2.2 of manual, faking optional named arguments</li><li>with is a pun == def, lenses</li></ul></aside></section><section><h2>Trace</h2><img width="600" src="./meetup/trace.svg"></section><section><h2>Snug</h2><img width="300" src="./meetup/snug.svg"><pre><code data-trim="contenteditable" class="haskell">h = hexagon 1 # fc lightgreen

sOrigin = showOrigin&#39; (with &amp; oScale .~ 0.04)

diagram :: Diagram B
diagram = h # alignR # sOrigin
      -- why not snugBL ?
       &lt;&gt; h # snugB # snugL # sOrigin
       &lt;&gt; h # snugT # snugL # sOrigin
</code></pre><aside class="notes"><ul><li>This cannot be done using align since envelopes prevent overlap</li><li>same align but uses trace instead of envelope</li></ul></aside></section></section><section><section><h2>A 2 Mirror Kaleidoscope</h2><img width="500" src="./meetup/kaleidoscope_by_mandelfish.jpg"><aside class="notes"><ul><li>reflected isoceles triangles, 2n-gons</li><li>8-gon, 360 / 8 = 45 degree central anlge</li><li>random confetti in chamber</li></ul></aside></section><section><h2>Preliminaries</h2><pre><code data-trim="contenteditable" class="haskell">import           Control.Monad                 (replicateM)
import           Control.Monad.Random
import           Data.Colour.Palette.ColorSet
import           Data.List                     (zipWith, zipWith3)
import           Diagrams.Prelude
import           Diagrams.Backend.SVG.CmdLine
import           System.Random

sizeValue :: (RandomGen g) =&gt; Rand g Double
sizeValue = getRandomR (0.05, 0.25)

coordValue :: (RandomGen g) =&gt; Rand g Double
coordValue = getRandomR (-0.5, 0.5)
</code></pre><aside class="notes"><ul><li>palette</li><li>MonadRandom: Rand g, evalRand</li><li>not restricted to a fixed set of confetti, like a real kaleidoscope</li></ul></aside></section><section><h2>Generating The Confetti</h2><pre><code data-trim="contenteditable" class="haskell">confetti :: Int -&gt; Rand StdGen (Diagram B)
confetti n = do
  ss &lt;- replicateM n sizeValue   -- radius
  cs &lt;- replicateM n getRandom   -- color index
  as &lt;- replicateM n getRandom   -- opacity
  xs &lt;- replicateM n coordValue  -- x coordinate
  ys &lt;- replicateM n coordValue  -- y coordinate
  let mkCirc :: Double -&gt; Int -&gt; Double -&gt; Diagram B
      mkCirc s c a = circle s # fc (webColors c)
                              # opacity a # lw none
      pos  = zipWith mkP2 xs ys
      conf = zipWith3 mkCirc ss cs as
  return $ position (zip pos conf)
</code></pre><aside class="notes"><ul><li>position :: [(Point v n , a)] -&gt; a</li><li>atPoints :: [Point v n] -&gt; [a] -&gt; a</li></ul></aside></section><section><h2>Generating The Confetti</h2><h3>seed = 0, pieces = 50</h3><img width="400" src="./meetup/mirror.svg"><aside class="notes"><ul><li>evalRand $ confetti n (mkStdGen 0)</li></ul></aside></section><section><h2>Cut out a Triangle</h2><pre><code data-trim="contenteditable" class="haskell">isoceles :: (TrailLike t, V t ~ V2) =&gt; Int -&gt; t
isoceles n = polygon
  (def &amp; polyType   .~ PolySides [deg1 @@ turn, deg2 @@ turn] [1,1]
       &amp; polyOrient .~ OrientH )
  where
  deg1 = 1/2 - (1 / fromIntegral n)
  deg2 = 1/2 - 1/2 * deg1

mkTriangle :: Int -&gt; Diagram B -&gt; Diagram B
mkTriangle n = clipped tri # lw none
  where
  tri = isoceles n # rotateBy (-1/4 - 1 / (2 * fromIntegral n))
</code></pre><aside class="notes"><ul><li>A wedge might be better</li><li>TrailLike t</li><li>def and lens</li><li>clipBy - envelope of diagram</li><li>clipTo - envelope is pointwise min</li><li>clipped - envelope of clipping path</li></ul></aside></section><section><h2>The Triangle</h2><img width="400" src="./meetup/mirror2.svg"></section><section><h2>Reflect the Triangle</h2><h3>outlines just for visualization</h3><img width="400" src="./meetup/mirror4.svg"></section><section><h2>Keep reflecting</h2><img width="500" src="./meetup/mirror5.svg"></section><section><h2>The Kaleidoscope</h2><pre><code data-trim="contenteditable" class="haskell">iterateIdx :: Integral i =&gt; (i -&gt; a -&gt; a) -&gt; a -&gt; [a]
iterateIdx f t = go f t 0
  where
    go f t i = let t&#39; = f i t
               in  t&#39;: go f t&#39; (i + 1)

kaleidoscope :: Diagram B -&gt; Int -&gt; Diagram B
kaleidoscope d n = mconcat . take n $ iterateIdx next tri
  where
    tri    = alignBR $ mkTriangle n d
    next t = reflectAbout
             (0 ^&amp; 0)
             (rotateBy (-fromIntegral t / fromIntegral n) xDir)
</code></pre><aside class="notes"><ul><li>Generalize to n triangles</li><li>directions - xDir</li><li>mconcat - atop</li></ul></aside></section><section><h2>The Kaleidoscope</h2><h3>60 degrees, 6 triangles</h3><img width="400" src="./meetup/mirror3.svg"></section><section><h2>The Kaleidoscope</h2><h3>36 degrees, 10 triangles</h3><img width="400" src="./meetup/mirror6.svg"></section></section><section><section><h2>Making GIFs with diagrams</h2><img width="400" src="./meetup/pendulum.gif"><aside class="notes"><ul><li>creating 3d GIFs by adding 2 lines</li><li>collaboration with juicy pixels</li><li>cairo, rasterific</li><li>beesandbombs.tumblr.com</li></ul></aside></section><section><h2>Pendulum</h2><h3>The Background</h3><img width="300" src="./meetup/stripes.svg"><pre><code data-trim="contenteditable" class="haskell">stripes :: Diagram B
stripes = (strutX 32
      ||| stripe
      ||| strutX 32
      ||| stripe
      ||| strutX 30) # center
  where stripe = square 100 # scaleX 0.03 # fc white # lc white
</code></pre><aside class="notes"><ul><li> GIFs have no alpha</li><li>dont need the black square</li></ul></aside></section><section><h2>Pendulum</h2><h3>The Ball</h3><img width="400" src="./meetup/ball.png"><pre><code data-trim="contenteditable" class="haskell">radial :: Texture Double
radial = mkRadialGradient (mkStops [(white,0,1), (black,1,1)])
                          ((-0.25) ^&amp; (0.25)) 0.1 (0 ^&amp; 0) 1.5
                          GradPad
</code></pre></section><section><h2>Pendulum</h2><pre><code data-trim="contenteditable" class="haskell">pend :: V2 Double -&gt; Diagram B
pend v = bob # translate (e .-. origin) &lt;&gt; rope
  where
    ellipsePath :: Diagram B
    ellipsePath = circle 25 # scaleX 1.5
    bob = scale size $ circle 1 # fillTexture radial # lw none
    size = 3.5 * sqrt (2 - y)
    rope = arrowBetween&#39; (with &amp; shaftStyle %~ lw thick # lc gray
                               &amp; arrowHead .~ noHead) s e
    s = (0 ^&amp; 50)
    e = fromMaybe origin (rayTraceP origin v ellipsePath)
    (x, y) = unr2 v -- v ^. r2Iso
</code></pre></section><section><h2>Pendulum</h2><h3>All together now</h3><pre><code data-trim="contenteditable" class="haskell">mkFrame :: V2 Double -&gt; Diagram B
mkFrame v
  | (snd $ unr2 v) &gt; 0 = stripes &lt;&gt; pend v
  -- |  v ^. (r2Iso . _2) &gt; 0 ...
  | otherwise = pend v &lt;&gt; stripes

dias = map mkFrame vs
  where vs = [fromDirection $ rotateBy(a/100) xDir | a &lt;- [0..99]]

delays = take 100 (repeat 3)

gif :: [(Diagram B, Int)]
gif = zip dias delays

main = mainWith $ gif
</code></pre></section><section><h2>A 3 Mirror Kaleidoscope</h2><img width="400" src="./meetup/kaleidoscope.gif"></section></section><section><h2>TrailLike</h2><pre><code data-trim="contenteditable" class="haskell">class (Metric (V t), OrderedField (N t)) =&gt; TrailLike t where
  trailLike :: Located (Trail (V t) (N t)) -&gt; t

instance (Metric v, OrderedField n) =&gt; TrailLike [Point v n] where
  trailLike = trailPoints

instance (Metric v, OrderedField n) =&gt; TrailLike (Path v n) where
  trailLike = Path . (:[])

instance (TypeableFloat n, Renderable (Path V2 n) b)
    =&gt; TrailLike (QDiagram b V2 n Any) where
  trailLike = strokeP . trailLike</code></pre></section><section><section><h1>Design Challenge</h1><h2>What&#39;s so tricky about arrows?</h2></section><section><h2>Arrows</h2><ul><li>We usually don&#39;t want arrow heads to scale with the diagram.</li><li>Arrows should connect the same points before and after scaling.</li><li>Arrow heads can be translucent - no overlap with the head.  This means the head needs to be connected to the shaft with a joint.</li><li>As we will see, this requires the joint size to depend on the line width.</li><li>Shafts can be any curve not just straight lines.</li></ul></section><section><h2>Scale Invariance</h2><h3>We usually don&#39;t want arrow heads to scale</h3><img width="400" src="./meetup/arrows1.svg"><aside class="notes"><ul><li>Don&#39;t want head size to change</li><li>Non uniform scaling can cause a preceived rotation</li></ul></aside></section><section><h2>Scale Invariance</h2><h3>But then the shaft can end up too small</h3><img width="500" src="./meetup/arrows2.svg"></section><section><h2>Arrow heads and tails</h2><img width="600" src="./meetup/arrowheads.svg"><aside class="notes"><ul><li>If we have an arrow head with a concave back, it will leave a gap when connected to a shaft</li></ul></aside></section><section><h2>This is why we need joints</h2><h3>The dart arrow head with a fat shaft</h3><img width="600" src="./meetup/nojoint.svg"><aside class="notes"><ul><li>So the size of the joint depends on the line width</li><li>Line width is very flexible in diagrams and we don&#39;t know it  at the time the arrow is made.</li></ul></aside></section><section><h2>Line Width</h2><h3>may be scaled:</h3><ul><li>to absolute size (pixels) </li><li>to a percentage of diagram size</li><li>locally (like length)</li><li>globally (for backward compatibility)</li></ul></section><section><h2>The Diagram type</h2><pre><code data-trim="contenteditable" class="haskell">type Diagram b = QDiagram b (V b) (N b) Any

newtype QDiagram b v n m
  = QD (DUALTree (DownAnnots v n)
                 (UpAnnots b v n m)
                  Annotation
                 (QDiaLeaf b v n m) )
  deriving Typeable

data QDiaLeaf b v n m
  = PrimLeaf (Prim b v n)
  | DelayedLeaf (DownAnnots v n -&gt; n -&gt; n -&gt; QDiagram b v n m)
  deriving Functor
</code></pre></section><section><h2>The Diagram type</h2><pre><code data-trim="contenteditable" class="haskell">type UpAnnots b v n m = Deletable (Envelope v n)
                    ::: Deletable (Trace v n)
                    ::: Deletable (SubMap b v n m)
                    ::: Query v n m
                    ::: ()

type DownAnnots v n = (Transformation v n :+: Style v n)
                  ::: Name
                  ::: ()

data Annotation
  = Href String    -- ^ Hyperlink
  | OpacityGroup Double
  deriving Show
</code></pre></section><section><h2>Arrow API</h2><img width="600" src="./meetup/arrows.svg"></section><section><h2>Arrow Options</h2><h3>Can&#39;t just simply apply a style</h3><pre><code data-trim="contenteditable" class="haskell">data ArrowOpts n
  = ArrowOpts
    { _arrowHead  :: ArrowHT n
    , _arrowTail  :: ArrowHT n
    , _arrowShaft :: Trail V2 n
    , _headGap    :: Measure n
    , _tailGap    :: Measure n
    , _headStyle  :: Style V2 n
    , _headLength :: Measure n
    , _tailStyle  :: Style V2 n
    , _tailLength :: Measure n
    , _shaftStyle :: Style V2 n
    }
</code></pre></section></section></div></div><script src="lib/js/head.min.js"></script><script src="js/reveal.js"></script><script>Reveal.initialize({ controls: true, progress: true, history: true, center: true, transition: 'slide', dependencies: [ { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } }, { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }, { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }, { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } }, { src: 'plugin/zoom-js/zoom.js', async: true }, { src: 'plugin/notes/notes.js', async: true } ] });</script></body></html>